"""Bias field artifact simulation via smooth multiplicative field."""

import numpy as np
from typing import Union, Tuple
from MriWizard.core.base import Record
from MriWizard.core.utils import fft2c, ifft2c, to_complex64, to_float32

class RandomBiasFieldImage:
    """Apply smooth multiplicative bias field to image domain."""
    
    def __init__(self,
                 coeff_range: Union[Tuple[float, float], None] = None,
                 sigma_frac_range: Union[Tuple[float, float], None] = None,
                 order: int = 3):
        """
        Initialize bias field transform.
        
        Args:
            coeff_range: Range for polynomial coefficients (min, max)
            sigma_frac_range: Range for Gaussian smoothing kernel size as fraction of image size
            order: Polynomial order (ignored in this NumPy implementation, uses Gaussian field)
        
        Bias field is generated by creating a random smooth field via Gaussian convolution.
        """
        if coeff_range is None:
            coeff_range = (0.0, 0.5)
        if sigma_frac_range is None:
            sigma_frac_range = (0.1, 0.3)
        
        self.coeff_range = coeff_range
        self.sigma_frac_range = sigma_frac_range
        self.order = order
    
    def _create_gaussian_kernel(self, shape: Tuple[int, ...], sigma: float) -> np.ndarray:
        """Create Gaussian kernel in frequency domain for convolution."""
        # Create frequency grids
        grids = []
        for size in shape:
            freq = np.fft.fftfreq(size).astype(np.float32)
            grids.append(freq)
        
        # Create meshgrid
        if len(shape) == 2:
            ky, kx = np.meshgrid(grids[0], grids[1], indexing='ij')
            k_squared = kx**2 + ky**2
        elif len(shape) == 3:
            kz, ky, kx = np.meshgrid(grids[0], grids[1], grids[2], indexing='ij')
            k_squared = kx**2 + ky**2 + kz**2
        else:
            # 1D or higher D
            k_squared = sum(g**2 for g in np.meshgrid(*grids, indexing='ij'))
        
        # Gaussian in frequency domain
        gaussian_fft = np.exp(-2.0 * (np.pi * sigma)**2 * k_squared).astype(np.float32)
        
        return gaussian_fft
    
    def __call__(self, record: Record) -> Record:
        """
        Apply bias field to image.
        
        Args:
            record: Input record
            
        Returns:
            Record with bias-field-corrupted image/kspace
        """
        # Get image (convert from k-space if needed)
        had_kspace_only = False
        if record["image"] is not None:
            image = to_float32(record["image"])
        elif record["kspace"] is not None:
            image = to_float32(ifft2c(record["kspace"]))
            had_kspace_only = True
        else:
            raise ValueError("Record must have either kspace or image")
        
        # Sample parameters
        coeff = np.random.uniform(self.coeff_range[0], self.coeff_range[1])
        sigma_frac = np.random.uniform(
            self.sigma_frac_range[0],
            self.sigma_frac_range[1]
        )
        
        # Get spatial shape (last 2 or 3 dimensions)
        spatial_shape = image.shape[-2:]  # Assume 2D for simplicity
        
        # Generate random field
        # Start with random noise
        random_field = np.random.randn(*spatial_shape).astype(np.float32)
        
        # Smooth via Gaussian convolution in Fourier domain
        sigma = sigma_frac * min(spatial_shape)
        
        # FFT of random field
        field_fft = np.fft.fftn(random_field)
        
        # Create Gaussian kernel
        gaussian_kernel = self._create_gaussian_kernel(spatial_shape, sigma)
        
        # Convolve (multiply in Fourier domain)
        smoothed_fft = field_fft * gaussian_kernel
        
        # IFFT to get smooth field
        smooth_field = np.real(np.fft.ifftn(smoothed_fft)).astype(np.float32)
        
        # Normalize to have controlled range
        smooth_field = smooth_field / (np.std(smooth_field) + 1e-8)
        
        # Create multiplicative bias: 1 + coeff * field
        bias_field = 1.0 + coeff * smooth_field
        
        # Ensure positive
        bias_field = np.abs(bias_field)
        
        # Broadcast to match image shape
        if image.ndim > 2:
            for _ in range(image.ndim - 2):
                bias_field = np.expand_dims(bias_field, axis=0)
            bias_field = np.broadcast_to(bias_field, image.shape)
        
        # Apply bias field
        biased_image = image * bias_field
        
        # Update record
        if had_kspace_only:
            # Convert back to k-space
            record["kspace"] = fft2c(to_complex64(biased_image))
        else:
            record["image"] = biased_image
            # Also update k-space if it exists
            if record["kspace"] is not None:
                record["kspace"] = fft2c(to_complex64(biased_image))
        
        record["metadata"]["applied"].append({
            "transform": "RandomBiasFieldImage",
            "coeff": float(coeff),
            "sigma_frac": float(sigma_frac),
            "order": int(self.order)
        })
        
        return record

